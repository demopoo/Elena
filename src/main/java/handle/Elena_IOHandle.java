package handle;import sun.security.provider.SHA;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.ClosedChannelException;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.LinkedList;import java.util.concurrent.atomic.AtomicBoolean;/** * Created by demopoo on 2017/9/22. */public abstract class Elena_IOHandle implements Runnable {    public Selector selector;    public SocketChannel socketChannel;    public SelectionKey selectionKey;    public volatile LinkedList<byte[]> linkedListReadQueue = new LinkedList<>();    public volatile ByteBuffer writeBuffer;    public volatile ByteBuffer readBuffer = ByteBuffer.allocateDirect(1024);    //发送数据队列按照先到先发规则    public volatile LinkedList<ByteBuffer> linkedListWriteQueue = new LinkedList<>();    private AtomicBoolean atomicBooleanW = new AtomicBoolean(false);    private AtomicBoolean atomicBooleanR = new AtomicBoolean(false);    public Elena_IOHandle(Selector selector, SocketChannel socketChannel) throws Exception{        socketChannel.configureBlocking(false);        this.selector = selector;        this.socketChannel = socketChannel;        this.selectionKey = socketChannel.register(selector,SelectionKey.OP_READ);        this.selectionKey.attach(this);        //回复连接成功        this.onConnection();    }    @Override    public void run() {        System.out.println("当前执行线程名称--"+Thread.currentThread().getName());        try {            if (selectionKey.isReadable()){                this.onRead();            }else if (selectionKey.isWritable()){                this.doWriteToChannel(writeBuffer);            }        }catch (Exception ex){            ex.printStackTrace();        }    }    /**     * 连接成功过后进行处理     */    public abstract void onConnection() throws IOException;    /**     * 关闭连接后的处理     */    public abstract void onClosed() throws IOException;    /**     * 发送数据实现类     * @param bytes 待发送的数据     */    public void onWrite(byte[] bytes) throws IOException{        while (!atomicBooleanW.compareAndSet(false,true)){        }       try {           ByteBuffer byteBuffer = writeBuffer;           if (writeBuffer == null && linkedListWriteQueue.isEmpty()){               doWriteToChannel(ByteBuffer.wrap(bytes));           }else {               linkedListWriteQueue.add(ByteBuffer.wrap(bytes));               doWriteToChannel(byteBuffer);           }       }finally {           atomicBooleanW.set(false);       }    }    public void doWriteToChannel(ByteBuffer byteBuffer) throws IOException{        //这里应该用公共Buffer的处理方式处理        socketChannel.write(byteBuffer);        if (byteBuffer.hasRemaining()){            this.writeBuffer = byteBuffer;            selectionKey.interestOps(selectionKey.interestOps() &~ SelectionKey.OP_READ | SelectionKey.OP_WRITE);        }else{            if (linkedListWriteQueue.isEmpty()){                selectionKey.interestOps(selectionKey.interestOps() &~ SelectionKey.OP_WRITE | SelectionKey.OP_READ);            }else {                ByteBuffer bf = linkedListWriteQueue.removeFirst();                bf.flip();                doWriteToChannel(bf);            }        }    }    /**     * 读取Channel中的数据     * noDecode 模式     * @return     */    public void onRead() throws IOException{        while (!atomicBooleanR.compareAndSet(false,true)){        }        try {            int len = 0;            while ((len = socketChannel.read(readBuffer)) > 0){                readBuffer.flip();                byte[] bt = new byte[readBuffer.limit()];                readBuffer.get(bt);                System.out.println(new String(bt));                linkedListReadQueue.add(bt);                readBuffer.clear();            }        }finally {            atomicBooleanR.set(false);        }    }    /**     * 读取channel中数据     * Decode 模式     * @param o     * @return     * @throws IOException     */    public Object onRead(Object o) throws IOException{        return null;    }}