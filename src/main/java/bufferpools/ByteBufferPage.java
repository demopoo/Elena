package bufferpools;import java.nio.ByteBuffer;import java.util.BitSet;import java.util.concurrent.atomic.AtomicBoolean;/** * Created by demopoo on 2017/9/22. * 模仿内存页设计 ，每个内存页由多个内存块组成 */public class ByteBufferPage {    private ByteBuffer byteBuffer;    private int chunkSize;    private int chunkCount;    //主要用于记录哪些内存块已经被分配出去    public BitSet bitSet = new BitSet();    private AtomicBoolean atomicBoolean = new AtomicBoolean(false);    public ByteBufferPage(ByteBuffer byteBuffer,int chunkSize){        this.byteBuffer = byteBuffer;        this.chunkSize = chunkSize;        this.chunkCount = this.byteBuffer.capacity()/chunkSize + (this.byteBuffer.capacity()%chunkSize==0?0:1);        bitSet.set(chunkCount);    }    /**     * 从当前页申请内存块     * @param applyChunkCount 申请的内存块数量     * @return     */    public ByteBuffer allocate(int applyChunkCount){        while (!atomicBoolean.compareAndSet(false,true)){            //采用 cas 算法非阻塞达到同步        }        int recordStartCount = -1,cumulativeChunkCount = 0;        try {            for (int i=0;i<chunkCount;i++){                if (bitSet.get(i)){                    recordStartCount = -1;                    cumulativeChunkCount = 0;                }else {                    if (recordStartCount == -1){                        recordStartCount = i;                    }                    if ((++cumulativeChunkCount) == applyChunkCount){                        break;                    }                }            }            if (cumulativeChunkCount == applyChunkCount){                int pos = recordStartCount * chunkSize;                int limit = pos + cumulativeChunkCount * chunkSize;                byteBuffer.position(pos);                byteBuffer.limit(limit);                ByteBuffer bBuffer = this.byteBuffer.slice();                markChunkUsed(recordStartCount,cumulativeChunkCount);                return bBuffer;            }else {                return null;            }        }finally {            atomicBoolean.set(false);        }    }    /**     * 标记已经被分配出去的内存块     * @param startCount 标记开始位置     * @param len 块数量     */    public void markChunkUsed(int startCount,int len){        for (int i = 0;i < len;i++){            bitSet.set(startCount+i);        }    }    /**     * 表已经被回收的内存块     * @param startCount     * @param len     */    public void markChunkUnUsed(int startCount,int len){        for (int i = 0;i < len;i++){            bitSet.clear(startCount+i);        }    }    /**     * 回收缓冲区     * @param byteBuffer 待回收缓冲区     * @param startChunk 回收开始内存块     * @param chunkCount 回收内存块个数     * @return     */    public boolean recycle(ByteBuffer byteBuffer,int startChunk,int chunkCount){        try {            while (!atomicBoolean.compareAndSet(false,true)){                Thread.yield();            }            if (byteBuffer == this.byteBuffer){                markChunkUnUsed(startChunk,chunkCount);                return true;            }            return false;        }finally {            atomicBoolean.set(false);        }    }}