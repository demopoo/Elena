package bufferpools;import java.nio.ByteBuffer;import java.util.concurrent.atomic.AtomicBoolean;/** * Created by demopoo on 2017/9/22. * 单个缓冲区重复利用方案 */public class ReuseByteBuffer {    public final ByteBuffer byteBuffer;    public int writeIndex;    public int readIndex;    //一次只允许一个线程进行读或写操作    private AtomicBoolean atomicBoolean = new AtomicBoolean(false);    public ReuseByteBuffer(ByteBuffer byteBuffer){        this.byteBuffer = byteBuffer;    }    /**     * 往缓冲区写数据     * @param bytes     */    public ReuseByteBuffer put(byte[] bytes){        try {            while (!atomicBoolean.compareAndSet(false,true)){            }            byteBuffer.position(writeIndex);            byteBuffer.limit(byteBuffer.capacity());            byteBuffer.put(bytes);            this.writeIndex = byteBuffer.position();            return this;        }finally {            atomicBoolean.set(false);        }    }    /**     * 往缓冲区写入制定位置，制定长度的数据     * @param bytes     * @param offset     * @param length     * @return     */    public ReuseByteBuffer put(byte[] bytes,int offset,int length){        try {            while (!atomicBoolean.compareAndSet(false,true)){            }            byteBuffer.position(writeIndex);            byteBuffer.limit(byteBuffer.capacity());            byteBuffer.put(bytes,offset,length);            writeIndex = byteBuffer.position();            return this;        }finally {            atomicBoolean.set(false);        }    }    /**     * 冲缓冲区里面取bytes[] 数据     * @param bytes     * @return     */    public byte[] get(byte[] bytes){        try {            while (!atomicBoolean.compareAndSet(false,true)){            }            if (bytes.length > byteBuffer.limit() - byteBuffer.position())                throw new IndexOutOfBoundsException();            byteBuffer.position(readIndex);            byteBuffer.get(bytes);            readIndex = byteBuffer.position();            if(byteBuffer.get(readIndex) == 0)                writeIndex = readIndex;            return bytes;        }finally {            atomicBoolean.set(false);        }    }    /**     * 压缩缓冲区     */    public ReuseByteBuffer compact(){        byteBuffer.position(readIndex);        byteBuffer.compact();        readIndex = 0;        writeIndex = byteBuffer.position();        return this;    }}